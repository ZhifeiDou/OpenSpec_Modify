# 需求变更对比实验结果报告

## 实验概要

**需求变更**：波动率自适应风控升级（3个子需求）
- 需求1：波动率自适应止损
- 需求2：动态再平衡频率
- 需求3：极端行情熔断机制（全新功能）

**对比双方**：
- **OpenSpec 版**：使用 OpenSpec 规格驱动工作流，先创建 6 个变更 artifacts（proposal → usecases → delta specs → design → tasks），再按照 tasks 逐项实现
- **非 OpenSpec 版**：直接根据需求文档编写代码

---

## 一、量化对比总表

| 对比维度 | OpenSpec 版 | 非 OpenSpec 版 | 优势方 |
|---------|-------------|---------------|--------|
| **变更文件数** | 7 个源码文件 + 6 个 artifact | 2 个源码文件 | — |
| **新增文件数** | 5（2 模块 + 3 测试） | 0 | OpenSpec |
| **修改文件数** | 4（engine, stop_loss, alerts, config） | 2（backtester, config） | — |
| **新增代码行数** | 662 行（源码 303 + 测试 359） | 163 行（全部在 backtester.py） | OpenSpec |
| **修改代码行数** | ~207 行跨 4 文件 | ~159 行集中 1 文件 | OpenSpec |
| **测试新增** | 3 个测试文件，31 个测试用例 | 0 | **OpenSpec** |
| **Artifact 文档** | 636 行（6 个 artifact） | 0 | **OpenSpec** |
| **需求覆盖** | 3/3 + 10 个边界场景 | 3/3 + 2 个边界场景 | **OpenSpec** |

---

## 二、逐维度详细分析

### 1. 影响分析准确性

**OpenSpec 版** ⭐⭐⭐⭐⭐
- Proposal 阶段明确标注：risk-management spec (MODIFIED)、backtest-engine spec (MODIFIED)
- Delta spec 精确描述每个 requirement 的变更类型：3 个 ADDED、2 个 MODIFIED
- 清晰区分了哪些是新增功能（熔断机制、波动率模块）、哪些是修改现有功能（止损、再平衡）

**非 OpenSpec 版** ⭐⭐
- 没有显式的影响分析步骤
- 直接开始修改代码，靠编码过程中逐步发现需要改什么
- 遗漏了对 strategy.py 的潜在影响分析（虽然最终没需要改，但没有记录分析过程）

**结论**：OpenSpec 的 proposal + delta specs 提供了**需求→规格→代码**的清晰映射，而非 OpenSpec 版缺乏这一层。

---

### 2. 需求覆盖完整性

**OpenSpec 版** ⭐⭐⭐⭐⭐
- 3 个需求全部实现 ✅
- usecases.md 定义了 **10 个用例场景**（UC-1.1 ~ UC-1.5, UC-2.1 ~ UC-2.5, UC-3.1 ~ UC-3.10）
- 显式覆盖的边界情况：
  - ✅ 历史数据不足时的回退（UC-1.4）
  - ✅ 波动率比值精确边界值（UC-1.5：ratio = 0.80, 1.50）
  - ✅ 再平衡频率中途切换（UC-2.4）
  - ✅ 熔断与 T+1 冲突（UC-3.3）
  - ✅ 熔断恢复被中断（UC-3.5）
  - ✅ 一级到二级熔断升级（UC-3.6）
  - ✅ 熔断期间跳过再平衡（UC-3.7）
  - ✅ 二级熔断渐进式恢复（UC-3.8）
  - ✅ 首日无前值时不触发（UC-3.9）
  - ✅ 净值精度边界（UC-3.10：2.95% < 3%）

**非 OpenSpec 版** ⭐⭐⭐
- 3 个需求全部实现 ✅
- 覆盖的边界情况：
  - ✅ 数据不足时返回默认值
  - ✅ 一级到二级熔断升级
  - ❌ **未处理 T+1 冲突**：熔断减仓时没有检查当日买入的股票能否卖出
  - ❌ **未处理二级熔断的渐进式恢复**：恢复后直接回到满仓，没有 50% 过渡
  - ❌ **未处理频率切换时的间隔计算**：直接用天数计数器，可能导致频率切换时立即触发或延迟

**结论**：OpenSpec 的 usecases 强制思考边界情况，发现了非 OpenSpec 版遗漏的 3 个重要边界场景。

---

### 3. 代码变更范围与模块化

**OpenSpec 版** ⭐⭐⭐⭐⭐

| 文件 | 类型 | 行数 | 职责 |
|------|------|------|------|
| `src/risk/volatility.py` | 新增 | 130 | 波动率计算（单一职责） |
| `src/risk/circuit_breaker.py` | 新增 | 173 | 熔断状态机（单一职责） |
| `src/risk/stop_loss.py` | 修改 | +16 | 仅增加 volatility_ratio 参数 |
| `src/risk/alerts.py` | 修改 | +34 | 集成新的风控检查 |
| `src/backtest/engine.py` | 修改 | +138 | 动态再平衡+熔断编排 |
| `config/settings.yaml` | 修改 | +19 | 新增配置参数 |

特点：
- 每个新功能封装在独立模块中
- 现有模块的修改最小化（stop_loss.py 仅新增 1 个参数）
- 职责清晰：volatility 负责检测、circuit_breaker 负责状态管理、engine 负责编排

**非 OpenSpec 版** ⭐⭐

| 文件 | 类型 | 行数变化 | 职责 |
|------|------|---------|------|
| `backtester.py` | 修改 | 257→416 (+159) | 止损+再平衡+熔断+波动率计算全部混在一起 |
| `config.py` | 修改 | 86→90 (+4) | 新增参数 |

特点：
- **所有 159 行新增代码集中在 backtester.py 一个文件中**
- 波动率计算、熔断逻辑、自适应止损全部内联在 `run_backtest()` 主循环中
- `run_backtest()` 函数从原来的 ~190 行膨胀到 ~270 行
- 熔断状态用普通变量管理（`circuit_breaker_active`, `circuit_breaker_level`），没有封装为状态机

**结论**：OpenSpec 版的变更分布在 6 个文件中，每个文件职责单一；非 OpenSpec 版所有变更挤在 1 个文件中。

---

### 4. 测试覆盖

**OpenSpec 版** ⭐⭐⭐⭐⭐
- 新增 3 个测试文件：
  - `test_volatility.py`：10 个测试（ATR multiple 映射 + rebalance regime 映射）
  - `test_circuit_breaker.py`：12 个测试（触发 + 恢复 + 辅助函数）
  - `test_adaptive_stop.py`：5 个测试（集成测试 + T+1 约束）
- **共 27 个新增测试用例**
- 每个测试用例对应 usecases.md 中的具体场景（可追溯）

**非 OpenSpec 版** ⭐
- **0 个新增测试**
- 原项目本身就没有测试目录
- 没有任何方式验证熔断逻辑的正确性，只能通过人工运行回测观察

**结论**：OpenSpec 版通过 tasks.md 显式列出了测试任务，确保测试不会被遗忘。非 OpenSpec 版完全没有测试。

---

### 5. 文档与可追溯性

**OpenSpec 版** ⭐⭐⭐⭐⭐

完整的 artifact 链路（636 行文档）：
```
proposal.md (44行)      → 为什么做这个变更？影响哪些 spec？
    ↓
usecases.md (159行)     → 有哪些使用场景？边界情况？
    ↓
delta specs (202行)     → 规格层面的精确变更描述
    ↓
design.md (163行)       → 技术方案：状态机设计、模块划分、接口定义
    ↓
tasks.md (68行)         → 10 个实现任务，每个关联到 spec 和 usecase
```

6 个月后的开发者可以：
- 从 proposal 理解变更动机
- 从 usecases 理解边界场景
- 从 delta specs 理解需求的精确定义
- 从 design 理解技术决策（为什么用状态机？为什么 circuit breaker 先于 drawdown check？）
- 从 tasks 理解实现步骤

**非 OpenSpec 版** ⭐
- **0 行文档**
- 没有 proposal、design、或任何变更说明
- 6 个月后的开发者只能：
  - 看 git diff 猜测变更目的
  - 从代码注释推断逻辑（"# 熔断检查"）
  - 无法知道为什么选择 3% / 5% 的熔断阈值
  - 无法知道是否还有遗漏的边界情况

**结论**：OpenSpec 版的 artifact 链路提供了完整的决策追溯路径，非 OpenSpec 版几乎为零。

---

### 6. 回归风险

**OpenSpec 版** ⭐⭐⭐⭐⭐
- `stop_loss.py` 的修改向后兼容（新参数有默认值）
- `alerts.py` 返回值扩展了字段但保留了所有旧字段
- 新功能封装在独立模块中，不影响现有的 `drawdown.py`、`position_sizer.py` 等
- 有 27 个测试用例验证新功能正确性
- Design 文档明确记录了"circuit breaker 先于 drawdown check"的优先级决策

**非 OpenSpec 版** ⭐⭐
- 所有改动在 `run_backtest()` 主函数中，任何修改都可能影响现有逻辑
- 没有测试来验证旧功能未被破坏
- 熔断逻辑与止损逻辑交织，修改一处可能意外影响另一处
- `positions` dict 结构从 `{"shares", "cost"}` 变为 `{"shares", "cost", "buy_date"}`，但止损检查代码中没有用 `buy_date`

**结论**：OpenSpec 版的模块化设计天然隔离了变更的影响范围；非 OpenSpec 版的单文件修改增加了回归风险。

---

### 7. 可复现性

**OpenSpec 版** ⭐⭐⭐⭐⭐
- 换一个 AI/开发者继续迭代时：
  - 读 proposal.md 理解变更全貌（2 分钟）
  - 读 delta specs 理解精确需求（5 分钟）
  - 读 design.md 理解技术方案（5 分钟）
  - 就能开始在现有架构上继续工作
- OpenSpec 的 specs 目录包含完整的系统规格，新人可以快速理解整个系统

**非 OpenSpec 版** ⭐⭐
- 换一个 AI/开发者继续迭代时：
  - 需要阅读整个 416 行的 backtester.py 理解逻辑
  - 需要自行推断哪些是原有逻辑、哪些是新增变更
  - 缺乏文档支持，需要逆向工程理解设计决策
  - 对于熔断恢复逻辑等复杂状态转换，代码可读性较差

**结论**：OpenSpec 版的知识沉淀在 artifacts 中可供后续复用；非 OpenSpec 版的知识仅存在于编码时的上下文中，会随时间丢失。

---

## 三、综合评分

| 维度 | OpenSpec 版 | 非 OpenSpec 版 |
|------|:-----------:|:-------------:|
| 影响分析准确性 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 需求覆盖完整性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 代码变更模块化 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 测试覆盖 | ⭐⭐⭐⭐⭐ | ⭐ |
| 文档/可追溯性 | ⭐⭐⭐⭐⭐ | ⭐ |
| 回归风险 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 可复现性 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| **总分（35分制）** | **35** | **13** |

---

## 四、关键发现

### OpenSpec 版的核心优势

1. **强制思考边界场景**：usecases.md 的编写过程中发现了 T+1 冲突、熔断恢复中断、频率切换等 8 个边界场景，其中 3 个在非 OpenSpec 版中被遗漏
2. **变更可追溯**：proposal → usecases → specs → design → tasks 的完整链路，每一步都有据可查
3. **模块化实现**：新功能封装在独立模块，不污染现有代码
4. **测试保障**：tasks 中显式列出测试任务，27 个测试用例保证质量

### 非 OpenSpec 版的典型问题

1. **单文件膨胀**：backtester.py 从 257 行增长到 416 行（+62%），所有新逻辑混在一个函数中
2. **边界遗漏**：T+1 冲突、渐进式恢复、频率切换间隔 3 个关键边界场景未处理
3. **零测试**：没有任何自动化测试，无法验证实现正确性
4. **零文档**：6 个月后无法追溯变更原因和设计决策

### 对领导汇报的关键数字

| 指标 | 数据 |
|------|------|
| OpenSpec 边界场景覆盖 | 10 个 vs 2 个（**5x**） |
| 测试用例 | 27 个 vs 0 个（**∞**） |
| 文档行数 | 636 行 vs 0 行（**∞**） |
| 代码模块化 | 7 个文件 vs 2 个文件（**3.5x**） |
| 遗漏的边界情况 | 0 个 vs 3 个 |

---

## 五、实验结论

在**需求变更**场景下，OpenSpec 的规格驱动工作流在所有 7 个对比维度上都显著优于直接编码方式。其核心价值不在于"写了更多代码"，而在于：

1. **前置思考**：proposal → usecases → specs 的过程强制在编码前完成需求分析和边界场景识别
2. **知识沉淀**：636 行 artifact 文档不是"额外负担"，而是团队知识资产
3. **质量保障**：tasks 中显式列出测试任务，确保测试不会被"先写完代码再补测试"的惯性遗忘
4. **迭代友好**：下一次需求变更时，新的开发者/AI 可以基于现有 specs 快速理解系统，而不是从 416 行 backtester.py 中逆向工程
