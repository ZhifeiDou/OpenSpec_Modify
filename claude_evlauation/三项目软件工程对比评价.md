# A股有色金属量化机器人 — 三项目软件工程对比评价

> **评价日期**: 2026-02-26
>
> **评价维度**: 需求与规格、设计、实现、验证与确认、维护与演进
>
> **评价对象**:
> - **A**: `superpower_testing/` — Superpowers 技能驱动构建的量化机器人
> - **B**: `testing_project_quant/` — OpenSpec 工作流构建的量化项目
> - **C**: `testing_project_quant_native_openspec/` — Native OpenSpec 工作流构建的量化项目

---

## 项目概览

| | **A: superpower_testing_quant** | **B: testing_project_quant** | **C: native_openspec** |
|---|---|---|---|
| **构建方式** | Superpowers 技能驱动 | OpenSpec 工作流 | Native OpenSpec 工作流 |
| **代码量** | ~1,600 LOC | ~5,000 LOC | ~3,400 LOC |
| **测试量** | 420 LOC / 27 tests | 779 LOC / 9 files | 570 LOC / 8 files |
| **因子数量** | 10 个因子 | 16 个因子 | 16 个因子 |
| **规格文档** | 2 份设计文档 | 8 份 OpenSpec specs | 8 份 specs + design + proposal + tasks |

---

## 1. 需求与规格 (Requirements & Specifications)

| 维度 | A: Superpowers | B: OpenSpec | C: Native OpenSpec |
|------|:-:|:-:|:-:|
| **评分** | **5/10** | **8/10** | **9/10** |

**A (Superpowers)**: 需求通过交互式问答收集（我问你答），最终沉淀为 2 份 Markdown 设计文档。但缺乏结构化需求规格——没有明确的验收标准、没有 WHEN/THEN 场景、没有非功能需求定义。需求和实现计划混在一起。

**B (OpenSpec)**: 有 8 份结构化 spec 文件，每个子系统独立规格。使用 Gherkin 风格的 WHEN/THEN 场景定义验收标准。配置参数详尽（30+ 参数）。但需求是跟随实现逐步形成的。

**C (Native OpenSpec)**: 最完整的需求工程。除了 8 份 spec，还有 `proposal.md`（业务论证）、`design.md`（6 个架构决策 + 权衡分析 + 备选方案）、`tasks.md`（74 个任务清单全部标记完成）。需求→设计→任务的追溯链最清晰。明确标注了"非目标"（不做实盘交易接口），减少范围蔓延。

> **结论**: C > B >> A。OpenSpec 工作流在需求结构化和可追溯性上远超 Superpowers 的交互式收集。

---

## 2. 设计 (Design)

| 维度 | A: Superpowers | B: OpenSpec | C: Native OpenSpec |
|------|:-:|:-:|:-:|
| **评分** | **7/10** | **8.5/10** | **8.5/10** |

**A (Superpowers)**:
- 简洁的分层架构（Data → Factor → Strategy → Backtest → Signal）
- `BaseFactor` 抽象基类 + 4 个具体因子类
- 配置化设计（YAML 驱动）
- **不足**: 回测引擎 212 行集中在一个类，职责过多；没有数据验证层；没有报告模块；缺少数据源容错

**B (OpenSpec)**:
- 更成熟的分层架构，8 个独立模块
- **工厂/注册表模式**：`@register_factor` 装饰器自动注册因子
- **策略模式**：`BaseSource` 抽象基类 + 多数据源实现
- 事件驱动回测引擎，分离了 `SimulatedBroker`（交易规则）和 `Portfolio`（状态管理）
- 完整的报告模块（Plotly 交互式 HTML）
- **亮点**: 子行业约束（铜/铝/金/锂/钴/锌/稀土）、IC 加权评分、市场择时模块

**C (Native OpenSpec)**:
- 架构与 B 类似但更精简（2,120 vs 3,909 LOC）
- 同样的多数据源容错（AKShare → BaoStock → Tushare 三级降级）
- SQLite 缓存层设计更清晰（专门的 `cache.py`）
- **亮点**: 设计文档中明确记录了 6 个架构决策及其权衡（为什么选 SQLite 而不是 PostgreSQL，为什么用事件驱动而不是向量化回测等）

> **结论**: B ≈ C > A。B 和 C 在模块化、设计模式运用、A 股交易规则建模上显著领先。A 胜在简洁，但牺牲了完整性。

---

## 3. 实现 (Implementation)

| 维度 | A: Superpowers | B: OpenSpec | C: Native OpenSpec |
|------|:-:|:-:|:-:|
| **评分** | **7/10** | **8/10** | **7.5/10** |

**A (Superpowers)**:
- 代码简洁（717 LOC 生产代码），易读性好
- 因子计算正确（RSI、ATR、z-score 标准化）
- **不足**: 缺少类型注解；T+1 规则未实现；涨跌停未处理；交易成本模型简单（只有手续费+滑点，无印花税）；100 手整手约束在回测中实现但不够严谨

**B (OpenSpec)**:
- 最完整的实现（3,909 LOC）
- **T+1 规则完整实现**（OrderQueue + buy_dates 字典追踪）
- **涨跌停处理**（10% 限制，买入/卖出分别检查）
- **真实交易成本**（印花税 0.05% 卖出单向 + 佣金 0.03% 双向最低 5 元 + 滑点 0.15%）
- 16 个因子覆盖 5 大类（商品/基本面/技术/资金流/宏观）
- IC 加权评分 + IC_IR 计算
- **数据验证层** + 增量更新
- Plotly 交互式 HTML 报告

**C (Native OpenSpec)**:
- 实现介于 A 和 B 之间（2,120 LOC）
- 同样实现了 T+1、涨跌停、完整交易成本
- 16 因子 + IC 加权
- **三数据源容错**（AKShare → BaoStock → Tushare）
- SQLite 增量缓存
- **不足**: 部分边界情况用 `fillna(0)` 静默处理，可能掩盖数据质量问题

### A 股合规性对比

| 特性 | A | B | C |
|------|:-:|:-:|:-:|
| T+1 规则 | ✗ | ✓ | ✓ |
| 涨跌停处理 | ✗ | ✓ | ✓ |
| 停牌检测 | ✓ (volume=0) | ✓ | ✓ |
| 印花税 | ✗ | ✓ | ✓ |
| 最低佣金 | ✗ | ✓ (5元) | ✓ (5元) |
| 100手整手 | ✓ | ✓ | ✓ |
| 多数据源容错 | ✗ | ✓ (2源) | ✓ (3源) |
| 子行业约束 | ✗ | ✓ | ✓ |

> **结论**: B > C > A。B 的实现最完整、最贴近 A 股真实交易环境。A 缺少关键的 A 股交易规则实现。

---

## 4. 验证与确认 (Verification & Validation)

| 维度 | A: Superpowers | B: OpenSpec | C: Native OpenSpec |
|------|:-:|:-:|:-:|
| **评分** | **7.5/10** | **7/10** | **5.5/10** |

**A (Superpowers)**:
- **27 个单元测试，全部通过**
- 测试:代码比 ≈ 1:1.7（420 LOC 测试 / 717 LOC 代码）— 最高的测试密度
- 每个模块都有对应测试
- TDD 驱动开发（先写测试，后实现）
- 使用 `pytest fixtures`、`tmp_path`、模拟数据
- **不足**: 缺少集成测试；无压力测试；无端到端流水线测试

**B (OpenSpec)**:
- 779 LOC 测试，9 个测试文件
- **有端到端集成测试** (`test_integration.py`, 195 LOC) — 唯一有集成测试的项目
- 测试覆盖回测力学、数据验证、因子标准化、风控、策略、择时、报告
- `conftest.py` 提供公共 fixtures
- `pytest.ini` 规范化测试配置
- **不足**: 测试:代码比 ≈ 1:5，密度相对较低

**C (Native OpenSpec)**:
- 570 LOC 测试，8 个测试文件
- 测试:代码比 ≈ 1:3.7
- T+1、涨跌停、交易成本有专门测试
- **不足**: 无集成测试；部分测试文件内容不够深入；估计覆盖率 ~40-50%

### 测试特征对比

| 测试特征 | A | B | C |
|----------|:-:|:-:|:-:|
| 单元测试数量 | 27 | ~25+ | ~20+ |
| 集成测试 | ✗ | ✓ | ✗ |
| 测试密度 (测试LOC/代码LOC) | 59% | 20% | 27% |
| TDD 驱动 | ✓ | 部分 | ✗ |
| 边界条件测试 | ✓ | ✓ | ✓ |
| 模拟数据 fixtures | ✓ | ✓ | ✓ |

> **结论**: A ≈ B > C。A 的测试密度最高且 TDD 驱动，B 胜在唯一有集成测试。C 测试最薄弱。

---

## 5. 维护与演进 (Maintenance & Evolution)

| 维度 | A: Superpowers | B: OpenSpec | C: Native OpenSpec |
|------|:-:|:-:|:-:|
| **评分** | **7/10** | **8.5/10** | **8/10** |

**A (Superpowers)**:
- **扩展新因子**: 继承 `BaseFactor` → 实现 `calculate()` → 注册到引擎（手动）
- 模块内聚性好，耦合度低
- **不足**: 无因子注册表（需手动添加到 BacktestEngine）；无数据源抽象（只有 AKShare）；回测引擎 212 行单类难以拆分；无报告模块需后续添加

**B (OpenSpec)**:
- **扩展新因子**: `@register_factor` 装饰器自动注册 → 更新 YAML 权重 → 完成
- **扩展数据源**: 继承 `BaseSource` → 自动进入容错链
- 模块完全独立（数据层不知道策略层的存在）
- 完整的报告系统（HTML + Plotly 图表）
- **最佳实践**: 无循环依赖、延迟导入、上下文管理器
- 30+ 配置参数支持无代码调优

**C (Native OpenSpec)**:
- 扩展模式与 B 类似
- 三数据源容错设计利于长期维护
- 最详尽的架构决策文档（design.md 记录了为什么这样做，未来可回溯）
- 74 个任务清单 + 完成状态 → 进度可追踪
- **不足**: 缺少 README/快速开始指南；新人上手成本高

### 演进能力对比

| 演进能力 | A | B | C |
|----------|:-:|:-:|:-:|
| 添加新因子复杂度 | 中等（手动注册） | 低（装饰器自动） | 低（装饰器自动） |
| 添加新数据源 | 高（需重写） | 低（继承接口） | 低（继承接口） |
| 配置化调参 | ✓ (15参数) | ✓ (30+参数) | ✓ (30+参数) |
| 架构决策可追溯 | ✗ | 部分（spec中） | ✓（design.md详尽） |
| 新人可读性 | 高（代码简洁） | 中等（代码量大） | 中等 |

> **结论**: B > C > A。B 的注册表模式和数据源抽象使扩展最低成本；C 的架构决策文档利于长期演进；A 简单但扩展性有限。

---

## 综合评分

| 维度 | A: Superpowers | B: OpenSpec | C: Native OpenSpec |
|------|:-:|:-:|:-:|
| 1. 需求与规格 | 5 | 8 | **9** |
| 2. 设计 | 7 | **8.5** | **8.5** |
| 3. 实现 | 7 | **8** | 7.5 |
| 4. 验证与确认 | **7.5** | 7 | 5.5 |
| 5. 维护与演进 | 7 | **8.5** | 8 |
| **总分** | **6.7** | **8.0** | **7.7** |

---

## 核心结论

**Superpowers (A)** 的优势是**速度和测试纪律** — TDD 驱动、测试密度最高、代码最精简。但在需求规格化和 A 股交易规则完整性上有明显短板。适合快速原型验证。

**OpenSpec (B)** 是**工程质量最均衡的方案** — 需求结构化、实现最完整（T+1/涨跌停/真实成本）、唯一有集成测试、扩展性最好。代码量最大但物有所值。适合研究级/准生产系统。

**Native OpenSpec (C)** 在**需求工程上最强** — 完整的 proposal→design→spec→tasks 追溯链、架构决策文档最详尽。实现质量介于 A 和 B 之间，但测试是三者中最弱的。适合需要严格文档化的团队协作场景。
