/**
 * Skill Template Workflow Modules
 *
 * This file is generated by splitting the legacy monolithic
 * templates file into workflow-focused modules.
 */
import type { SkillTemplate, CommandTemplate } from '../types.js';

export function getUseCasesSkillTemplate(): SkillTemplate {
  return {
    name: 'openspec-use-cases',
    description: 'Generate use cases through guided conversation. Use when the user wants to create use cases for their change, identifying actors, goals, and scenarios.',
    instructions: `Guide the user through creating use cases for their change.

**This is a CONVERSATIONAL workflow.** Unlike other artifacts that are written
in one shot, use cases are built through dialogue with the user.

**Steps**

1. **Read the proposal for context**
   Read the proposal.md to understand what's being built and why.

2. **Present Actor-Goal List**
   From the proposal, identify actors and their goals. Present to user:

   > I've identified these actors and goals from your proposal:
   >
   > | Actor | Goal |
   > |-------|------|
   > | Developer | Initialize project with AI tools |
   > | AI Agent | Get workflow instructions |
   >
   > Does this look right? Any actors or goals missing?

   Wait for user confirmation. Use AskUserQuestion if needed.

3. **Draft Main Success Scenarios**
   For each use case, draft the main success scenario:

   > **Use Case: Initialize Project**
   > Actor: Developer
   >
   > Main Success:
   > 1. Developer runs init command
   > 2. System creates directory structure
   > 3. System presents available AI tools
   > 4. Developer selects tools to configure
   > 5. System generates tool configurations
   > 6. System displays next steps
   >
   > Does this capture the right flow? Any steps to add or change?

4. **Brainstorm Extensions**
   For each step, ask about failures:

   > Looking at step 3 - what if the project is already initialized?
   > And step 4 - what if the user selects no tools?
   >
   > Let me draft the extensions:
   > 3a. Project already initialized → enter extend mode
   > 4a. No tools selected → create structure only

5. **Add Contract Elements**
   > For "Initialize Project", what must be true before starting?
   > (e.g., "user is in a project directory")
   > And what does the system guarantee even if something fails?

6. **Write the use-cases.md file**
   Once confirmed, write the complete use-cases.md

7. **Show progress and suggest next step**

**Guardrails**
- ALWAYS wait for user confirmation between steps
- Do NOT skip the conversation - the dialogue IS the value
- Each use case should have 3-9 main success steps
- Use Cockburn's conventions: verb phrases for names, numbered steps,
  step+letter for extensions (2a, 3b, etc.)
- Focus on actor intent, not UI details
- If user is unsure about extensions, suggest common failure patterns:
  invalid input, timeout, permission denied, duplicate action,
  external system failure`,
    license: 'MIT',
    compatibility: 'Requires openspec CLI.',
    metadata: { author: 'openspec', version: '1.0' },
  };
}

export function getOpsxUseCasesCommandTemplate(): CommandTemplate {
  return {
    name: 'OPSX: Use Cases',
    description: 'Create use cases through guided conversation - identify actors, goals, and scenarios (Experimental)',
    category: 'Workflow',
    tags: ['workflow', 'artifacts', 'experimental'],
    content: `Guide the user through creating use cases for their change.

**This is a CONVERSATIONAL workflow.** Unlike other artifacts that are written
in one shot, use cases are built through dialogue with the user.

**Input**: Optionally specify a change name after \`/opsx:use-cases\` (e.g., \`/opsx:use-cases add-auth\`). If omitted, check if it can be inferred from conversation context. If vague or ambiguous you MUST prompt for available changes.

**Steps**

1. **If no change name provided, prompt for selection**

   Run \`openspec list --json\` to get available changes sorted by most recently modified. Then use the **AskUserQuestion tool** to let the user select which change to work on.

   **IMPORTANT**: Do NOT guess or auto-select a change. Always let the user choose.

2. **Read the proposal for context**
   Read the proposal.md to understand what's being built and why.

3. **Present Actor-Goal List**
   From the proposal, identify actors and their goals. Present to user:

   > I've identified these actors and goals from your proposal:
   >
   > | Actor | Goal |
   > |-------|------|
   > | Developer | Initialize project with AI tools |
   > | AI Agent | Get workflow instructions |
   >
   > Does this look right? Any actors or goals missing?

   Wait for user confirmation. Use AskUserQuestion if needed.

4. **Draft Main Success Scenarios**
   For each use case, draft the main success scenario:

   > **Use Case: Initialize Project**
   > Actor: Developer
   >
   > Main Success:
   > 1. Developer runs init command
   > 2. System creates directory structure
   > 3. System presents available AI tools
   > 4. Developer selects tools to configure
   > 5. System generates tool configurations
   > 6. System displays next steps
   >
   > Does this capture the right flow? Any steps to add or change?

5. **Brainstorm Extensions**
   For each step, ask about failures:

   > Looking at step 3 - what if the project is already initialized?
   > And step 4 - what if the user selects no tools?
   >
   > Let me draft the extensions:
   > 3a. Project already initialized → enter extend mode
   > 4a. No tools selected → create structure only

6. **Add Contract Elements**
   > For "Initialize Project", what must be true before starting?
   > (e.g., "user is in a project directory")
   > And what does the system guarantee even if something fails?

7. **Write the use-cases.md file**
   Once confirmed, write the complete use-cases.md

8. **Show progress and suggest next step**
   \`\`\`bash
   openspec status --change "<name>"
   \`\`\`

**Guardrails**
- ALWAYS wait for user confirmation between steps
- Do NOT skip the conversation - the dialogue IS the value
- Each use case should have 3-9 main success steps
- Use Cockburn's conventions: verb phrases for names, numbered steps,
  step+letter for extensions (2a, 3b, etc.)
- Focus on actor intent, not UI details
- If user is unsure about extensions, suggest common failure patterns:
  invalid input, timeout, permission denied, duplicate action,
  external system failure`
  };
}
